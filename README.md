# DataStructure(C)-Beta版
**南京邮电大学数据结构C语言代码**

每个大章节中我会把文件程序具体是什么放在最前面，然后知识点放在程序后，所以可能顺序会有点不同，可以看

下面目录选择你喜欢的进行查看（ **想看程序分别对应是什么的** 可以直接 **点大章节标题**，比如我直接点树就能看到

对应程序的内容所指）（Github右边可以展开目录）

[TOC]

## 树

binarytree.c（先序、中序、后序遍历）

binarytree2.c（层次遍历）

binarytree3.c（应用-计算结点数量）

treeclear.c（递归清空二叉树）

### 树转化成二叉树

![](./image/bt0.png)

![](./image/bt1.png)

![](./image/bt3.png)

### 二叉树转化成森林

（左孩子，右兄弟）

![](./image/bt4.png)

![](./image/bt5.png)

![](./image/bt6.png)

### 树和森林的存储表示

![](./image/bt7.png)

![](./image/bt8.png)

![](./image/bt9.png)

其中这里的 `sibling` 表示原示例中兄弟结点的下标，比如说B和C是兄弟结点，然后A是-1，B是1，C是2，那么BC（B在C的左边）这个兄弟结点的的 `sibling` 的表示则为： `B -> C(2) -> A(-1)`，也就是上面图示的箭头指向，兄弟结点的最后一个（最右边的）的 `sibling` 即为他的父结点的位置下标

### 森林的遍历

![](./image/bt11.png)

![](./image/bt12.png)

![](./image/bt13.png)

![](./image/bt10.png)

总结就是：

- 森林先序/中序遍历与二叉树的思想基本相同，遍历完相加即可
- 森林后序遍历的头结点是从右往左一次遍历的（D -> A），并不是简单相加
- 层次也差不多



------

## 堆与优先权队列

heap1.c（向下调整算法 && 建堆运算）

queue1.c（优先权队列的实现）

### 什么是堆？

定义:从逻辑结构上看，一个大小为n的堆是一棵包含n个结点的 **完全二叉树**，根结点称为堆顶，包含如下两类：

- 最小堆:树中每个结点的数据都 **小于或等于** 其孩子结点，因此，在最小堆中，堆顶存储的数据是整棵树中最小的;
- 最大堆:树中每个结点的数据 **大于或等于** 其孩子结点，因此，在最大堆中，堆顶存储的数据是整棵树中最大的

![](./image/d1.png)

### 堆的存储表示

就拿上面那个最小堆来举例，堆的存储结构应该遵循的是层次遍历，也就是如下：

```
index:  0   1   2   3   4   5  ....
value: [18, 30, 24, 50, 46, 92]....
```

那么如何判断一个堆是最小堆还是最大堆？

你就从0开始按层次遍历排好，然后观察是不是 **每个结点** 都 **大于等于/小于等于** 其子结点就行

### 建堆运算

我们已知最后一个叶结点双亲的位置是 $$\lfloor\frac{(n-2)}{2}\rfloor$$ ($$\lfloor x\rfloor$$表示向下取整)，根结点位置为 0

**算法思想（最小堆）：** 从最后一个叶子的双亲($$K_{\lfloor(n-2)/2\rfloor}$$)**反方向** 直到根结点($$K_0$$)，依次对其中的每个结点($$K_i$$)执行向

下调整（AdjustDown）操作，步骤如下：

①若该结点小于或等于其最小的孩子，则本轮向下调整结束;否则执行步骤②;

②将该结点与最小孩子交换;交换完成后，继续以该结点为考查对象，再次执行步骤①；

关键算法：（完整代码可以见 heap1.c）

```c
void AdjustDown(ElemType heap[], int current, int border){
    int p = current;
    int minChild;
    ElemType temp;
    while(2 * p + 1 <= border){  // 若p不是叶结点，则执行
        if((2 * p + 2 <= border) && (heap[2 * p + 1] > heap[2 * p + 2]))
            minChild = 2 * p + 2;  // 右子树存在，且较小，则minChild指向p的右子树
        else
            minChild = 2 * p + 1;  // 右子树不存在或较大，则指向p的左子树
        if(heap[p] <= heap[minChild]){
            break;                 // 若当前结点不大于自己的最小的子树，则结束
        }
        else{                      // 否则就将p与最小的子树进行交换
            temp = heap[p];
            heap[p] = heap[minChild];
            heap[minChild] = temp;
            p = minChild;          // 设置下轮循环待考察元素的位置（当前下移元素位置）
        }
    }
}

void CreatHeap(ElemType heap[], int n){
    int i;
    for(i = (n-2)/2; i > -1; i--)      // 从最后一个叶结点的双亲方向到根结点
        AdjustDown(heap, i, n - 1);
}
```

### 优先权队列

**优先权队列** 是一种具有如下特性的数据结构：元素加入数据结构的次序无关紧要，但每次从该数据结构中取元素

时，都只取具有最高优先级的元素，这样的数据结构即为优先权队列

- 每个元素都应有一个优先权，且可以比较大小
- 元素按优先权的高低顺序依次出队，而不是按元素进入队列的先后顺序出队

**实现优先权队列的方法：**

- 进队：将新元素放在堆尾元素后面，并按照（最小堆）或最大堆进行适当调整 ($$O(log_2n)$$)
- 出队：直接取出堆顶元素($$O(1)$$)，取出后，按照（最小堆）或最大堆进行适当调整($$O(log_2n)$$)

**向上调整算法（最小堆）：**

- 设新元素插入在最小堆的元素序列的尾部
- 从新插入元素开始，自底向上，与父结点元素进行大小比较；若父结点大于子结点，则进行交换调整；直到父结点不再大于新元素子结点，或者新元素已经到达了堆顶

关键代码：（完整代码请见 queue1.c）

```c
// 向上调整
void AdjustUp(ElemType heap[], int current){
    int p = current;
    ElemType temp;
    while(p > 0){   // 如果p是根节点了则结束
        if(heap[p] < heap[(p - 1) / 2 ]){  //  // 如果p小于父结点，则进行交换
            temp = heap[p];
            heap[p] = heap[(p - 1) / 2 ];
            heap[(p - 1) / 2 ] = temp;
            p = (p - 1) / 2;   // 更新p的位置使其成为父结点  
        }else {
            break;
        }
    }
}
```

## 哈夫曼树与哈夫曼编码

huffmantree1.c（哈夫曼算法）

### 树的路径长度

**树的内路径长度**：除叶结点外，从根到树中其他所有结点的路径长度之和

![](./image/ht1.png)

**树的外路径长度**：从根到所有叶结点的路径长度之和

![](./image/ht2.png)

我们已知 **扩充二叉树（2-树）** 是一棵 **除了叶结点之外，每个结点都必须有两个子结点**，现在定义内路径长度和外路径长度分别为 `I` 和 `E`，叶结点数量为 `n`，那么有以下公式：

$$
E=I+2n
$$

**叶结点的加权路径长度**：设叶结点是带权的，则叶结点的加权路径长度是其长度与其权值的乘积

**树的加权路径长度**：所有叶结点的加权路径长度之和，记作 `WPL`，有如下公式：

$$
WPL=\sum_{k=1}^{m}w_k \times l_k
$$

其中， $$m$$ 是叶结点的数量， $$w_k$$ 是第 $$k$$ 个结点的权值(圆圈里的数值)， $$l_k$$ 是该叶结点的路径长度

![](./image/ht3.png)

**加权路径长度WPL的内涵**(结合字符编码应用场景)

- 每一个叶结点表示一个字符
- 叶结点权值表示对应字符在文本中的出现频度
- 叶结点的路径长度表示对应字符的编码长度

**WPL 表示的是一个文本最终转换成编码之后的总编码长度**

### 哈夫曼树和哈夫曼算法

**哈夫曼算法**：求具有最小加权路径长度二叉树的算法

**哈夫曼树**:用哈夫曼算法构造生成的二又树

- 哈夫曼树是一棵扩充二叉树
- 哈夫曼树中任一 **非叶节点的权值** 等于其 **左右孩子的权值之和**
- 对于叶节点相同二叉树而言，哈夫曼树的 **加权路径长度是最小的**

由下面的例子来呈现哈夫曼算法的具体步骤：

现有集合 `W = {3, 5, 9, 11, 12，13}`，我们先选取最小的两个权值构成二叉树，即 3 和 5，构造如下：

`F = {8，9，11，12，13}`，其中 <8，3>，<8，5>

![](./image/ht4.png)

然后循环上述步骤，我们能得到 <17，8>，<17，9>

![](./image/ht5.png)

然后我们再选择 11 和 12 进行组合，以此类推，最终生成一个新的二叉树

![](./image/ht6.png)

关键代码如下：（伪代码）（非伪代码可以看 huffmantree1.c）

```c
// 创建哈夫曼树
BinaryTree CreateHFMTree(int w[], int m){
    BinaryTree x, y, z;
    CreatPQ(PQ, m);                       // 初始化用于存储二叉树的优先权队列，权值存在根结点数据域
    for(int i = 0; i< m; i++){
        MakeTree(x, w[i], NULL, NULL);    // 创建只包含根结点的二叉树，并把权值存在根结点数据域
        Append(PQ, x);                    // 将二叉树存入优先权队列
    }
    while(PQ.n > 1){
        Serve(PQ, x);
        Serve(PQ, y);                        // 这两步对应哈夫曼算法中取出两个最小的结点进行结合
        if(x.root.element < y.root.element)  // 设置左子树的权值小于右子树
            MakeTree(z, x.root.element + y.root.element, x, y);
        else
            MakeTree(z, x.root.element + y.root.element, y, x);
        Append(PQ, z);                       // 将合并后的二叉树加入优先权队列
    }
    Serve(PQ, x);          // 获取优先权队列中唯一的二叉树（完整的哈夫曼树），并存入x
    return x;
}
```

### 哈夫曼编码

（为了调上面那个伪代码怒耗时3h，但是给自己定的ddl要到了，遂停摆）

![](./image/ht7.png)

![](./image/ht8.png)

**哈夫曼编码**

利用哈夫曼树构造哈夫曼编码：

已知文本的字符集S，以及对应的权值集合W，权值表示对应字符的频度，执行如下步骤：

1. 根据W构造哈夫曼树，叶结点权值代表对应的字符;
2. 按照左孩子分支标记编码0，右孩子分支标记编码1的原则(左0右1)，为哈夫曼树中的分支标记0/1编码;
3. 叶子节点对应字符的编码，即为从根结点到该叶子节点的路径中，经过各孩子分支所形成的0/1编码序列。

![](./image/ht9.png)



------

## 集合与搜索

jihe1.c（有序表顺序搜索，无序表顺序搜索，有哨兵的有序表顺序搜索）

jihe2.c（二分搜索）

### 集合的抽象数据类型

![](./image/jh1.png)

![](./image/jh2.png)

**常见的集合实现有三种：**

- 线性表（本章节采用线性表）
- 搜索树
- 散列表

**定义顺序表表示下的集合：**

```c
typedef struct {
    int n;
    int maxLength;
    ElemType *element;
}ListSet;
```

（ElementType表示可以比较的类型，要根据实际进行更改）

### 顺序搜索

**顺序表**：采用顺序存储表示来实现的线性表（申请连续的存储空间）

**顺序搜索**：在进行元素查找时，从线性表第一个元素开始，按照位置从前到后依次的进行元素的查找

**无序表的顺序搜索：**

从第一个元素开始，将指定待查找的元素x的关键字与表中元素的关键字一一比较

若相等，搜索成功；若搜索完整个表，不存在关键字值等于给定值的元素搜索失败，例如：

 (41，25，28，33，36，15)

33搜索成功! 35 搜索失败!（需要将每个元素都比较一遍）

顺序搜索无序表的代码实现：

```c
int SeqSearch(ListSet L, ElemType x){
    for(int i = 0; i < L.n; i++)
        if(L.element[i] == x)      // 一个一个搜索直到搜索到为止
            return i;
    return -1;
}
```

如果存在有序表（1， 25， 28， 33， 36， 45），我需要查找35，我可以对代码改动如下：

```c
int SeqSearchOrder(ListSet L, ElemType x){
    for(int i = 0; i < L.n; i++){
        if (L.element[i] == x)
            return i;
        else if(L.element[i] > x)    // 顺序表中是从小到大排列的
            return -1;
    }
    return -1;
}
```

也可以增加一个 **哨兵**（有序表最后添加一个无穷大的数）

```c
int SeqSearchSentry(ListSet L, ElemType x){
    L.element[L.n] = MaxNum;              // 将最后一个设置为无穷大
    for(int i = 0; L.element[i] < x; i++) 
    // 让L中的每个元素跟x比较，若匹配到了最后一个哨兵还没有x，就说明搜索失败
        if(L.element[i] == x)             // 一个一个搜索直到搜索到为止
            return i;
    return -1;
}
```

**对有序表进行顺序搜索比无序表上进行顺序搜索速度更快？**

错误。顺序搜索的时间复杂度在有序表和无序表上都是 O(n)，没有本质区别

### 二分搜索

此章节说明的二分搜索适用于有序表

![](./image/jh3.png)

**对半搜索是二分搜索中的一种，分割点为表的中点元素**： 

$$
m=\frac{low+high}{2}
$$

过程如下：

![](./image/jh4.png)

![](./image/jh5.png)

关键代码：

```c
int BinarySearch(ListSet L, ElemType x, int low, int high){
    if(low <= high){
        int m = (low + high) / 2;
        if(L.element[m] > x)
            return BinarySearch(L, x, low, m - 1); // 中点比x大，说明x在左半边
        else if(L.element[m] < x)
            return BinarySearch(L, x, m + 1, high);// 中点比x小，说明x在右半边
        else
            return m;
    }
    else
        return -1;
}
```

也可以使用while循环：

```c
int BinarySearch(ListSet L, ElemType x){
    int m, low = 0;
    int high = L.n - 1;
    while(low <= high){
     	m = (low + high) / 2;
        if(L.element[m] > x)
            return BinarySearch(L, x, low, m - 1); // 中点比x大，说明x在左半边
        else if(L.element[m] < x)
            return BinarySearch(L, x, m + 1, high);// 中点比x小，说明x在右半边
        else
            return m;  
    }    
    return -1;
}
```

### 平均搜索长度分析

分析一个搜索算法的时间复杂度通常分搜索成功以及搜索失败两种情况加以讨论

为了确定一个指定关键字值的记录在表中的位置，需要进行关键字值之间的比较，这些比较次数的期望值称为搜索

算法的 **平均搜索长度( average search length ASL)**

#### 无序表的顺序搜索

(1)成功搜索的平均搜索长度

设表中元素a,被搜索的概率p;，假定每个元素的搜索概率相等即 $$p_i=\frac{1}{n}$$ ，则搜索成功时的平均搜索长度为：

$$
ASL_s=\sum_{i=1}^{n}i \times p_i=\frac{1}{n}\sum_{i=1}^{n}=\frac{n+1}{2}
$$

(2)搜索失败的平均搜索长度

该函数在搜索失败的情况下，总要进行 **n次** 关键字值之间的比较 

#### 有序表的顺序搜索

(1)成功搜索的平均搜索长度

**与无序表相同**，其公式如下

$$
ASL_s=\sum_{i=1}^{n}i \times p_i=\frac{1}{n}\sum_{i=1}^{n}=\frac{n+1}{2}
$$

(2)搜索失败的平均搜索长度

在搜索失败的情况下，**平均搜索长度大约比无序时快一倍**，其公式如下：

$$
ASL_F=1+\sum_{i=1}^{n+1}i \times \frac{1}{n+1}=2+\frac{n}{2}
$$

其中，循坏内比较了 $$1+\frac{n}{2}$$ 次，判断跳出循环又比较了 $$1$$ 次

![](./image/jh6.png)

#### 二叉判定树构造

![](./image/jh7.png)

![](./image/jh8.png)

这样子构造可以保证每个内结点的左子树都是关键字更小的结点，而右子树都是关键字更大的结点

**搜索(二叉判定树T，k)**

(1)将 (l = 根结点的关键字) 与 (k) 进行比较

(2)如果 l=k，**成功搜索，返回**

(4)如果 I>k，如果T的左子树不为空，**搜索(T的左子树，k)**

**否则，搜索失败，返回**

(5)如果 l<k，如果T的右子树不为空，**搜索(T的右子树，k)**

**否则，搜索失败，返回**

**如果搜索成功，则算法在内结点处终止；否则算法在外结点处终止**

这样构造出来的二叉树有以下特征：(高度为 $$\lfloor log_2n \rfloor+1$$ 的二叉树 ) 

- 任意结点左右子树上结点个数差 = 1
- 左右子树高度差最多为 1

**定理**  对半搜索算法在成功搜索的情况下，关键字值之间的比较次数不超过 $$\lfloor log_2n \rfloor+1$$;对于不成功的搜索，算法需要作 $$\lfloor log_2n \rfloor$$ 或 $$\lfloor log_2n \rfloor+1$$ 次比较 

**定理** 对半搜索算法的成功/失败的平均时间复杂度为 $$O(log_2n)$$

![](./image/jh9.png)





------

## 搜索树

searchtree1.c（二叉搜索树的搜索、插入、删除）

### 二叉搜索树

#### 二叉搜索树的定义

**定义** 设结点由关键字值表征，假定所有结点的 **关键字值各不相同**，二叉搜索树或者是一棵空二叉树或者是具有下

列性质的二叉树:

(1)若左子树不空，则左子树上所有结点的关键字值均小于根结点关键字值;

(2)若右子树不空，则右子树上所有结点的关键字值均大于根结点关键字值;

(3)左、右子树也分别是二叉搜索树

![](./image/st1.png)

**性质** 若以中序遍历一棵二叉搜索树，将得到一个以关键字 **递增** 排列的有序序列

**中序遍历**：23 35 45 54 63 69 76 87

#### 二叉搜索树中序遍历的特征

任何一个结点：

- 左子树上的结点都在它的左侧排列;
- 右子树上的结点都在它的右侧排列，

再结合二叉搜索树左小右大的原则，任何一个结点：

- 左子树上的结点都在它的左侧排列且都比它小
- 右子树上的结点都在它的右侧排列且都比它大

#### 类型实现

定义值集合项类型 T 包含值与键

```c
typedef int KeyType;
struct entry{
    KeyType Key;
    DataType Data;
}Entry;
typedef struct Entry T;
```

定义搜索树：

```c
// 定义搜索树节点类型BTNode, 包含集合项、左右子树根结点指针
typedef struct btnode{
    T Element;
    struct btnode *lChild, *rChild;
}BTNode;

// 定义搜索树类型BTree，包含根结点
typedef struct btree{
    BTNode *root;
}BTree;
```

#### 二叉搜索树搜索操作

**二叉搜索树的搜索操作**

在一棵二叉搜索树上，查找关键字为k的元素

(1)若二叉树为空，则搜索失败

(2)否则，将k与根结点比较

- 若k小于该结点的关键字，则以同样的方法搜索左子树，而不必搜索右子树，
- 若k大于该结点的关键字，则以同样的方法搜索右子树，而不必搜索左子树，
- 若k等于该结点的关键字，则搜索成功终止

#### 二叉搜索树插入操作

![](./image/st2.png)

![](./image/st3.png)

关键代码：

```c
// 搜索树插入操作
bool Insert(BTree *bt, T x){
    BTNode *p = bt -> root, *q, *r;    // p指针从根结点出发一直到搜索结束
    KeyType k = x.Key;
    while(p){
        q = p;                         // q指针记录搜索失败处的上一层结点
        if ( k < p -> Element.Key)
            p = p -> lChild;
        else if (k > p -> Element.Key)
            p = p -> rChild;
        else
            return false;
    }
    r = NewNode(x);                   // 生成新结点
    if(!bt -> root)
        root = r;                     // r作用是指向新结点
    else if (k < q -> Element.Key)
        q -> lChild = r;              // q指针作用是记录新结点的双亲
    else 
        q - > rChild = r;
    return true;
}
```

#### 二叉搜索树删除操作

##### 删除叶结点

![](./image/st4.png)

##### 删除带一个子树的结点

![](./image/st5.png)

首先先断开33和35之间的连线，然后将33与34相连（33的右指针指向34），最后删除35

PS：不能直接删除，但是可以替代，比如上述就是让34替代了原本35的位置，而且 **不会影响有序性**

##### 删除两个子树的结点

![](./image/st6.png)

![](./image/st7.png)

**↑ 所选的代替者肯定没有右子树**

![](./image/st8.png)

**↑ 所选的代替者肯定没有左子树**

**删除有两个孩子的结点**

(1)在二叉搜索树上搜索待删除元素的结点 （**结点两个孩子都非空**）

(2)选择待删除结点在中席遍历序列下的直接 B 代替待删除节点

(3)删除重复的代替者

- 代替者没有孩子：直接删除
- 代替者有一个孩子：孩子直接代替后删除

![](./image/st9.png)



------

### 平衡树

#### 二叉平衡树的定义

二叉平衡树或者是一棵空二叉搜索树，或者是具有下列性质的二叉搜索树

(1)其根的左、右子树高度之差的绝对值不超过1;

(2)其根的左、右子树都是二叉平衡树

![](./image/ph1.png)

**定义** 结点的平衡因子

结点的平衡因子被定义为该结点的左子树高度减去右子树的高度

![](./image/ph2.png)



#### 二叉平衡树的插入运算

二又平衡树的插入运算可按如下两条基本原则进行：

- 原则1:先按普通二叉搜索树的插入方法插入结点以保持 **排序性** 
- 原则2:然后再判断二又平衡树的平衡性是否被破坏，从而决定是否需要调整 **平衡性**

![](./image/ph3.png)

如图，插入25后，任何根结点的左右子树高度差绝对值不超过1，所以25被正常插入

![](./image/ph4.png)

如图，插入14后，发现根结点的左右子树高度差绝对值大于1（12所在的根结点和33所在的根结点），所以插入失败，需要进行 **平衡性的调整**

**基本原则**：

- 找到需要调整的最小子树
- 调整最小子树的平衡性

**如何找到需要调整的最小子树？**

最小子树的根结点s 即为离新插入结点最近且平衡因子绝对值超过1的祖先结点，也就是插入后由新结点回溯至根结点的路径上第一个出现的非平衡结点

**如何调整最小子树的平衡性？**

根据 **新结点在最小子树s上的插入类型** 来选择不同的平衡

- (1)如果属于LL(RR)插入类型，即新结点插入s的左(右)子树的左(右)子树上，则采用单旋转方法
- (2)如果属于LR(RL)插入类型，即新结点插入s的左(右)子树的右(左)子树上，则采用双旋转方法

![](./image/ph5.png)

这里是LL的插入类型，也就是插入在14的左子树的左子树上，所以我们现在标记14为s，那么下一个12标记为r，然后就是将r和s沿顺时针方向转动，让s变成r的右子树

![](./image/ph6.png)

![](./image/ph7.png)

**二叉平衡树的插入算法**

在一棵二叉平衡树上，插入新元素的手工算法可描述如下：

1. 按照二叉搜索树的插入方式插入新元素
2. 判断插入新元素后的二叉平衡树其平衡性是否被破坏，如果平衡性没有破坏，则插入运算结束;
3. 否则，如果平衡性被破坏，则标记s结点为插入后由新结点回湖至根结点路径上第一个出现的非平衡结点，然后判断插入类型：

- 如果插入类型为 **LL/RR**，采用 **单旋转方式** 调整最小子树的平衡性
- 如果插入类型为 **LR/RL**，则采用 **双旋转方式** 调整最小子树的平衡性



### B-树

#### m叉搜索树的定义

![](./image/b1.png)

图中的方块代表空树

**空树** 也被称为 **失败结点**，因为这是当搜索某个关键字不在树中所到达的子树

失败结点中不包含元素，**失败结点不是叶结点**

**m叉搜索树的递归定义：**

![](./image/b2.png)

![](./image/b3.png)

从定义中可以得到：

(1)一个m叉搜索树的结点中，**最多** 存放 **m-1个元素** 和 **m个指向子树的指针**

(2)每个结点中包含的元素个数比它包含的指针数少1

**内搜索和外搜索**

**内搜索：**当集合足够小，可以驻留在内存中时，相应的搜索方法称为内搜索

**外搜索：**如果文件很大，以至于计算机内存容不下时，它们必须存放在外存中。在外存中搜索给定关键字值的元素的方法称为外搜索

**内存中**，集合用 **二叉平衡树** 表示。**外存中**，集合可以用一种特殊的 **m叉搜索树--B-树** 来表示

由于读取外存的速度要比内存慢百倍，所以平时读取外存就可以将二叉树压成B-树：

![](./image/b4.png)

如上图，将一棵高度为6的二叉搜索树压缩成单结点存放7个元素、高度为2的8叉树，大大提高了搜索速度

#### m叉搜索树的性质

**性质1**：高度为 $$h$$ 的 $$m$$ 叉搜索树中最多有 $$m^h-1$$ 个元素

**性质2**：含有 $$N$$ 个元素的 $$m$$ 叉搜索树的高度在 $$log_m(N-1)$$ 到 $$N$$ 之间

#### B-树的定义

**定义** 一颗m阶B-树是一棵m叉搜索树，它或者是空树，或者是满足以下特性的树：

- 根结点 **至少有两个** 孩子 （根结点可以只有一个元素）
- 除根结点和失败结点外的所有结点 **至少** 有 $$\lceil \frac{m}{2} \rceil$$ 个孩子 （保证B-树不会退化成单分支树）
- 所有失败结点均在同一层上

**如何判断是不是B-树？如何判断是几阶B-树？**

- 首先看失败结点是否在同一层上
- 其次查看根结点是否最少有两个孩子
- 然后确定m的值，并计算 $$\lceil \frac{m}{2}\rceil$$ 是多少
- 最后查看每个结点(根结点和失败结点除外)的孩子数量有没有少于 $$\lceil \frac{m}{2}\rceil$$ ？

![](./image/b5.png)

比如这个图，每个根结点下至少有2个孩子，所以此树既是3阶B-树，也是4阶B-树，但是绝对不可能是5阶B-树，因为 $$\lceil \frac{m}{2}\rceil$$ 至少为3，而图中存在有两个孩子的结点

#### B-树的性质

**性质1** 设B-树失败结点的总数是 $$s$$ ，那么，一棵B-树包含的元素总数 $$N$$ 是B-树的失败结点的总数 $$s-1$$ ，即 $$N=s-1$$

**性质2** 含有 $$N$$ 个元素的m阶B-树的高度 $$h$$ 有 $$h≤1+log_{\lceil \frac{m}{2}\rceil}\frac{N+1}{2}$$

#### B-树的搜索

在B-树上进行搜索的过程是一个 **顺时针查找结点**，和 **在结点的关键字中搜索** 交叉进行的过程

#### B-树的插入

B-树插入应遵循的基本原则：

- 首先执行 **搜索** 操作，判断元素是否存在;
- 如果元素不存在，则将元素依某种插入规则插入B-树;
- 如果插入后没有违反B-树的定义，则插入成功完成;否则需作相应调整

![](./image/b6.png)

![](./image/b7.png)

**上溢出**：关键字个数 > $$m-1$$

此时插入59后，结点个数突破上限3（上溢出），就要进行下一步调整操作：

![](./image/b8.png)

总结步骤如下：

- **Step 1**：搜索。在B-树中搜索给定关键字值的元素。如果搜索成功，表示有重复元素，则插入运算结束；**否则转Step 2将新元素插入搜索失败结点上一层处的叶子结点q中**
- **Step 2**：插入。将新元素和一个空指针插入结点q中。如果插入后，结点q未上溢出，即结点中包含的元素个数未超过 $$m-1$$ (指针数未超过m)，则插入运算结束。**否则转Step3进行结点的分裂操作**
- **Step 3**：分裂。以 $$\lceil \frac{m}{2}\rceil$$ 处的元素为分割点，将上溢出结点一分为三，然后将分割点元素和新结点插入双亲结点中。继续检查此双亲结点的上溢出问题。如果没有上溢出，则插入运算结束，**否则转Step 3继续该双亲结点的分裂操作，直至不再产生上溢出现**

**Tips**：如果按照Step3，**根结点产生分裂**，由于根结点没有双亲，那么分裂产生的两个结点的指针以及分割点元素将组成一个新的根结点，从而 **将导致B树长高一层**

#### B-树的删除

**B-树删除应遵循的基本原则**：

首先执行搜索操作，判断元素是否存在，如果被删除元素存在，则分情况执行删除操作：

- 情形1：被删除的元素 **在叶子结点上**。则直接从该叶子结点中删除该元素，并检查是否发生下溢出。如果没有下溢出，则删除运算结束，否则处理下溢出
- 情形2：被删除的元素 **不在叶子结点上**。则首先执行替代操作，用该元素右侧子树上的最小元素取代它，从而将问题转化为情形1

![](./image/b9.png)

![](./image/b10.png)











------

## 散列表

占位



------

## 图论

占位



------

## 排序

占位

# DataStructure(C)-Beta版
**南京邮电大学数据结构C语言代码**

每个大章节中我会把文件程序具体是什么放在最前面，然后知识点放在程序后，所以可能顺序会有点不同，可以看

下面目录选择你喜欢的进行查看（ **想看程序分别对应是什么的** 可以直接 **点大章节标题**，比如我直接点树就能看到

对应程序的内容所指）（Github右边可以展开目录）

[TOC]

## 树

binarytree.c（先序、中序、后序遍历）

binarytree2.c（层次遍历）

binarytree3.c（应用-计算结点数量）

treeclear.c（递归清空二叉树）

### 树转化成二叉树

![](./image/bt0.png)

![](./image/bt1.png)

![](./image/bt3.png)

### 二叉树转化成森林

（左孩子，右兄弟）

![](./image/bt4.png)

![](./image/bt5.png)

![](./image/bt6.png)

### 树和森林的存储表示

![](./image/bt7.png)

![](./image/bt8.png)

![](./image/bt9.png)

其中这里的 `sibling` 表示原示例中兄弟结点的下标，比如说B和C是兄弟结点，然后A是-1，B是1，C是2，那么BC（B在C的左边）这个兄弟结点的的 `sibling` 的表示则为： `B -> C(2) -> A(-1)`，也就是上面图示的箭头指向，兄弟结点的最后一个（最右边的）的 `sibling` 即为他的父结点的位置下标

### 森林的遍历

![](./image/bt11.png)

![](./image/bt12.png)

![](./image/bt13.png)

![](./image/bt10.png)

总结就是：

- 森林先序/中序遍历与二叉树的思想基本相同，遍历完相加即可
- 森林后序遍历的头结点是从右往左一次遍历的（D -> A），并不是简单相加
- 层次也差不多



------

## 堆与优先权队列

heap1.c（向下调整算法 && 建堆运算）

queue1.c（优先权队列的实现）

### 什么是堆？

定义:从逻辑结构上看，一个大小为n的堆是一棵包含n个结点的 **完全二叉树**，根结点称为堆顶，包含如下两类：

- 最小堆:树中每个结点的数据都 **小于或等于** 其孩子结点，因此，在最小堆中，堆顶存储的数据是整棵树中最小的;
- 最大堆:树中每个结点的数据 **大于或等于** 其孩子结点，因此，在最大堆中，堆顶存储的数据是整棵树中最大的

![](./image/d1.png)

### 堆的存储表示

就拿上面那个最小堆来举例，堆的存储结构应该遵循的是层次遍历，也就是如下：

```
index:  0   1   2   3   4   5  ....
value: [18, 30, 24, 50, 46, 92]....
```

那么如何判断一个堆是最小堆还是最大堆？

你就从0开始按层次遍历排好，然后观察是不是 **每个结点** 都 **大于等于/小于等于** 其子结点就行

### 建堆运算

我们已知最后一个叶结点双亲的位置是 $$\lfloor\frac{(n-2)}{2}\rfloor$$ ($$\lfloor x\rfloor$$表示向下取整)，根结点位置为 0

**算法思想（最小堆）：** 从最后一个叶子的双亲($$K_{\lfloor(n-2)/2\rfloor}$$)**反方向** 直到根结点($$K_0$$)，依次对其中的每个结点($$K_i$$)执行向

下调整（AdjustDown）操作，步骤如下：

①若该结点小于或等于其最小的孩子，则本轮向下调整结束;否则执行步骤②;

②将该结点与最小孩子交换;交换完成后，继续以该结点为考查对象，再次执行步骤①；

关键算法：（完整代码可以见 heap1.c）

```c
void AdjustDown(ElemType heap[], int current, int border){
    int p = current;
    int minChild;
    ElemType temp;
    while(2 * p + 1 <= border){  // 若p不是叶结点，则执行
        if((2 * p + 2 <= border) && (heap[2 * p + 1] > heap[2 * p + 2]))
            minChild = 2 * p + 2;  // 右子树存在，且较小，则minChild指向p的右子树
        else
            minChild = 2 * p + 1;  // 右子树不存在或较大，则指向p的左子树
        if(heap[p] <= heap[minChild]){
            break;                 // 若当前结点不大于自己的最小的子树，则结束
        }
        else{                      // 否则就将p与最小的子树进行交换
            temp = heap[p];
            heap[p] = heap[minChild];
            heap[minChild] = temp;
            p = minChild;          // 设置下轮循环待考察元素的位置（当前下移元素位置）
        }
    }
}

void CreatHeap(ElemType heap[], int n){
    int i;
    for(i = (n-2)/2; i > -1; i--)      // 从最后一个叶结点的双亲方向到根结点
        AdjustDown(heap, i, n - 1);
}
```

### 优先权队列

**优先权队列** 是一种具有如下特性的数据结构：元素加入数据结构的次序无关紧要，但每次从该数据结构中取元素

时，都只取具有最高优先级的元素，这样的数据结构即为优先权队列

- 每个元素都应有一个优先权，且可以比较大小
- 元素按优先权的高低顺序依次出队，而不是按元素进入队列的先后顺序出队

**实现优先权队列的方法：**

- 进队：将新元素放在堆尾元素后面，并按照（最小堆）或最大堆进行适当调整 ($$O(log_2n)$$)
- 出队：直接取出堆顶元素($$O(1)$$)，取出后，按照（最小堆）或最大堆进行适当调整($$O(log_2n)$$)

**向上调整算法（最小堆）：**

- 设新元素插入在最小堆的元素序列的尾部
- 从新插入元素开始，自底向上，与父结点元素进行大小比较；若父结点大于子结点，则进行交换调整；直到父结点不再大于新元素子结点，或者新元素已经到达了堆顶

关键代码：（完整代码请见 queue1.c）

```c
// 向上调整
void AdjustUp(ElemType heap[], int current){
    int p = current;
    ElemType temp;
    while(p > 0){   // 如果p是根节点了则结束
        if(heap[p] < heap[(p - 1) / 2 ]){  //  // 如果p小于父结点，则进行交换
            temp = heap[p];
            heap[p] = heap[(p - 1) / 2 ];
            heap[(p - 1) / 2 ] = temp;
            p = (p - 1) / 2;   // 更新p的位置使其成为父结点  
        }else {
            break;
        }
    }
}
```

## 哈夫曼树与哈夫曼编码

huffmantree1.c（哈夫曼算法）

### 树的路径长度

**树的内路径长度**：除叶结点外，从根到树中其他所有结点的路径长度之和

![](./image/ht1.png)

**树的外路径长度**：从根到所有叶结点的路径长度之和

![](./image/ht2.png)

我们已知 **扩充二叉树（2-树）** 是一棵 **除了叶结点之外，每个结点都必须有两个子结点**，现在定义内路径长度和外路径长度分别为 `I` 和 `E`，叶结点数量为 `n`，那么有以下公式：

$$
E=I+2n
$$

**叶结点的加权路径长度**：设叶结点是带权的，则叶结点的加权路径长度是其长度与其权值的乘积

**树的加权路径长度**：所有叶结点的加权路径长度之和，记作 `WPL`，有如下公式：

$$
WPL=\sum_{k=1}^{m}w_k \times l_k
$$

其中， $$m$$ 是叶结点的数量， $$w_k$$ 是第 $$k$$ 个结点的权值(圆圈里的数值)， $$l_k$$ 是该叶结点的路径长度

![](./image/ht3.png)

**加权路径长度WPL的内涵**(结合字符编码应用场景)

- 每一个叶结点表示一个字符
- 叶结点权值表示对应字符在文本中的出现频度
- 叶结点的路径长度表示对应字符的编码长度

**WPL 表示的是一个文本最终转换成编码之后的总编码长度**

### 哈夫曼树和哈夫曼算法

**哈夫曼算法**：求具有最小加权路径长度二叉树的算法

**哈夫曼树**:用哈夫曼算法构造生成的二又树

- 哈夫曼树是一棵扩充二叉树
- 哈夫曼树中任一 **非叶节点的权值** 等于其 **左右孩子的权值之和**
- 对于叶节点相同二叉树而言，哈夫曼树的 **加权路径长度是最小的**

由下面的例子来呈现哈夫曼算法的具体步骤：

现有集合 `W = {3, 5, 9, 11, 12，13}`，我们先选取最小的两个权值构成二叉树，即 3 和 5，构造如下：

`F = {8，9，11，12，13}`，其中 <8，3>，<8，5>

![](./image/ht4.png)

然后循环上述步骤，我们能得到 <17，8>，<17，9>

![](./image/ht5.png)

然后我们再选择 11 和 12 进行组合，以此类推，最终生成一个新的二叉树

![](./image/ht6.png)

关键代码如下：（伪代码）（非伪代码可以看 huffmantree1.c）

```c
// 创建哈夫曼树
BinaryTree CreateHFMTree(int w[], int m){
    BinaryTree x, y, z;
    CreatPQ(PQ, m);                       // 初始化用于存储二叉树的优先权队列，权值存在根结点数据域
    for(int i = 0; i< m; i++){
        MakeTree(x, w[i], NULL, NULL);    // 创建只包含根结点的二叉树，并把权值存在根结点数据域
        Append(PQ, x);                    // 将二叉树存入优先权队列
    }
    while(PQ.n > 1){
        Serve(PQ, x);
        Serve(PQ, y);                        // 这两步对应哈夫曼算法中取出两个最小的结点进行结合
        if(x.root.element < y.root.element)  // 设置左子树的权值小于右子树
            MakeTree(z, x.root.element + y.root.element, x, y);
        else
            MakeTree(z, x.root.element + y.root.element, y, x);
        Append(PQ, z);                       // 将合并后的二叉树加入优先权队列
    }
    Serve(PQ, x);          // 获取优先权队列中唯一的二叉树（完整的哈夫曼树），并存入x
    return x;
}
```

### 哈夫曼编码

（为了调上面那个伪代码怒耗时3h，但是给自己定的ddl要到了，遂停摆）

![](./image/ht7.png)

![](./image/ht8.png)

**哈夫曼编码**

利用哈夫曼树构造哈夫曼编码：

已知文本的字符集S，以及对应的权值集合W，权值表示对应字符的频度，执行如下步骤：

1. 根据W构造哈夫曼树，叶结点权值代表对应的字符;
2. 按照左孩子分支标记编码0，右孩子分支标记编码1的原则(左0右1)，为哈夫曼树中的分支标记0/1编码;
3. 叶子节点对应字符的编码，即为从根结点到该叶子节点的路径中，经过各孩子分支所形成的0/1编码序列。

![](./image/ht9.png)



------

## 集合与搜索

jihe1.c（有序表顺序搜索，无序表顺序搜索，有哨兵的有序表顺序搜索）

jihe2.c（二分搜索）

### 集合的抽象数据类型

![](./image/jh1.png)

![](./image/jh2.png)

**常见的集合实现有三种：**

- 线性表（本章节采用线性表）
- 搜索树
- 散列表

**定义顺序表表示下的集合：**

```c
typedef struct {
    int n;
    int maxLength;
    ElemType *element;
}ListSet;
```

（ElementType表示可以比较的类型，要根据实际进行更改）

### 顺序搜索

**顺序表**：采用顺序存储表示来实现的线性表（申请连续的存储空间）

**顺序搜索**：在进行元素查找时，从线性表第一个元素开始，按照位置从前到后依次的进行元素的查找

**无序表的顺序搜索：**

从第一个元素开始，将指定待查找的元素x的关键字与表中元素的关键字一一比较

若相等，搜索成功；若搜索完整个表，不存在关键字值等于给定值的元素搜索失败，例如：

 (41，25，28，33，36，15)

33搜索成功! 35 搜索失败!（需要将每个元素都比较一遍）

顺序搜索无序表的代码实现：

```c
int SeqSearch(ListSet L, ElemType x){
    for(int i = 0; i < L.n; i++)
        if(L.element[i] == x)      // 一个一个搜索直到搜索到为止
            return i;
    return -1;
}
```

如果存在有序表（1， 25， 28， 33， 36， 45），我需要查找35，我可以对代码改动如下：

```c
int SeqSearchOrder(ListSet L, ElemType x){
    for(int i = 0; i < L.n; i++){
        if (L.element[i] == x)
            return i;
        else if(L.element[i] > x)    // 顺序表中是从小到大排列的
            return -1;
    }
    return -1;
}
```

也可以增加一个 **哨兵**（有序表最后添加一个无穷大的数）

```c
int SeqSearchSentry(ListSet L, ElemType x){
    L.element[L.n] = MaxNum;              // 将最后一个设置为无穷大
    for(int i = 0; L.element[i] < x; i++) 
    // 让L中的每个元素跟x比较，若匹配到了最后一个哨兵还没有x，就说明搜索失败
        if(L.element[i] == x)             // 一个一个搜索直到搜索到为止
            return i;
    return -1;
}
```

**对有序表进行顺序搜索比无序表上进行顺序搜索速度更快？**

错误。顺序搜索的时间复杂度在有序表和无序表上都是 O(n)，没有本质区别

### 二分搜索

此章节说明的二分搜索适用于有序表

![](./image/jh3.png)

**对半搜索是二分搜索中的一种，分割点为表的中点元素**： 

$$
m=\frac{low+high}{2}
$$

过程如下：

![](./image/jh4.png)

![](./image/jh5.png)

关键代码：

```c
int BinarySearch(ListSet L, ElemType x, int low, int high){
    if(low <= high){
        int m = (low + high) / 2;
        if(L.element[m] > x)
            return BinarySearch(L, x, low, m - 1); // 中点比x大，说明x在左半边
        else if(L.element[m] < x)
            return BinarySearch(L, x, m + 1, high);// 中点比x小，说明x在右半边
        else
            return m;
    }
    else
        return -1;
}
```

也可以使用while循环：

```c
int BinarySearch(ListSet L, ElemType x){
    int m, low = 0;
    int high = L.n - 1;
    while(low <= high){
     	m = (low + high) / 2;
        if(L.element[m] > x)
            return BinarySearch(L, x, low, m - 1); // 中点比x大，说明x在左半边
        else if(L.element[m] < x)
            return BinarySearch(L, x, m + 1, high);// 中点比x小，说明x在右半边
        else
            return m;  
    }    
    return -1;
}
```

### 平均搜索长度分析

分析一个搜索算法的时间复杂度通常分搜索成功以及搜索失败两种情况加以讨论

为了确定一个指定关键字值的记录在表中的位置，需要进行关键字值之间的比较，这些比较次数的期望值称为搜索

算法的 **平均搜索长度( average search length ASL)**

#### 无序表的顺序搜索

(1)成功搜索的平均搜索长度

设表中元素a,被搜索的概率p;，假定每个元素的搜索概率相等即 $$p_i=\frac{1}{n}$$ ，则搜索成功时的平均搜索长度为：

$$
ASL_s=\sum_{i=1}^{n}i \times p_i=\frac{1}{n}\sum_{i=1}^{n}=\frac{n+1}{2}
$$

(2)搜索失败的平均搜索长度

该函数在搜索失败的情况下，总要进行 **n次** 关键字值之间的比较 

#### 有序表的顺序搜索

(1)成功搜索的平均搜索长度

**与无序表相同**，其公式如下

$$
ASL_s=\sum_{i=1}^{n}i \times p_i=\frac{1}{n}\sum_{i=1}^{n}=\frac{n+1}{2}
$$

(2)搜索失败的平均搜索长度

在搜索失败的情况下，**平均搜索长度大约比无序时快一倍**，其公式如下：

$$
ASL_F=1+\sum_{i=1}^{n+1}i \times \frac{1}{n+1}=2+\frac{n}{2}
$$

其中，循坏内比较了 $$1+\frac{n}{2}$$ 次，判断跳出循环又比较了 $$1$$ 次

![](./image/jh6.png)

#### 二叉判定树构造

![](./image/jh7.png)

![](./image/jh8.png)

这样子构造可以保证每个内结点的左子树都是关键字更小的结点，而右子树都是关键字更大的结点

**搜索(二叉判定树T，k)**

(1)将 (l = 根结点的关键字) 与 (k) 进行比较

(2)如果 l=k，**成功搜索，返回**

(4)如果 I>k，如果T的左子树不为空，**搜索(T的左子树，k)**

**否则，搜索失败，返回**

(5)如果 l<k，如果T的右子树不为空，**搜索(T的右子树，k)**

**否则，搜索失败，返回**

**如果搜索成功，则算法在内结点处终止；否则算法在外结点处终止**

这样构造出来的二叉树有以下特征：(高度为 $$\lfloor log_2n \rfloor+1$$ 的二叉树 ) 

- 任意结点左右子树上结点个数差 = 1
- 左右子树高度差最多为 1

**定理**  对半搜索算法在成功搜索的情况下，关键字值之间的比较次数不超过 $$\lfloor log_2n \rfloor+1$$;对于不成功的搜索，算法需要作 $$\lfloor log_2n \rfloor$$ 或 $$\lfloor log_2n \rfloor+1$$ 次比较 

**定理** 对半搜索算法的成功/失败的平均时间复杂度为 $$O(log_2n)$$

![](./image/jh9.png)





------

## 二叉搜索树

searchtree1.c（二叉搜索树的搜索、插入、删除）

### 二叉搜索树

#### 二叉搜索树的定义

**定义** 设结点由关键字值表征，假定所有结点的 **关键字值各不相同**，二叉搜索树或者是一棵空二叉树或者是具有下

列性质的二叉树:

(1)若左子树不空，则左子树上所有结点的关键字值均小于根结点关键字值;

(2)若右子树不空，则右子树上所有结点的关键字值均大于根结点关键字值;

(3)左、右子树也分别是二叉搜索树

![](./image/st1.png)

**性质** 若以中序遍历一棵二叉搜索树，将得到一个以关键字 **递增** 排列的有序序列

**中序遍历**：23 35 45 54 63 69 76 87

#### 二叉搜索树中序遍历的特征

任何一个结点：

- 左子树上的结点都在它的左侧排列;
- 右子树上的结点都在它的右侧排列，

再结合二叉搜索树左小右大的原则，任何一个结点：

- 左子树上的结点都在它的左侧排列且都比它小
- 右子树上的结点都在它的右侧排列且都比它大

#### 类型实现

定义值集合项类型 T 包含值与键

```c
typedef int KeyType;
struct entry{
    KeyType Key;
    DataType Data;
}Entry;
typedef struct Entry T;
```

定义搜索树：

```c
// 定义搜索树节点类型BTNode, 包含集合项、左右子树根结点指针
typedef struct btnode{
    T Element;
    struct btnode *lChild, *rChild;
}BTNode;

// 定义搜索树类型BTree，包含根结点
typedef struct btree{
    BTNode *root;
}BTree;
```

#### 二叉搜索树搜索操作

**二叉搜索树的搜索操作**

在一棵二叉搜索树上，查找关键字为k的元素

(1)若二叉树为空，则搜索失败

(2)否则，将k与根结点比较

- 若k小于该结点的关键字，则以同样的方法搜索左子树，而不必搜索右子树，
- 若k大于该结点的关键字，则以同样的方法搜索右子树，而不必搜索左子树，
- 若k等于该结点的关键字，则搜索成功终止

### 二叉搜索树插入操作

![](./image/st2.png)

![](./image/st3.png)

关键代码：

```c
// 搜索树插入操作
bool Insert(BTree *bt, T x){
    BTNode *p = bt -> root, *q, *r;    // p指针从根结点出发一直到搜索结束
    KeyType k = x.Key;
    while(p){
        q = p;                         // q指针记录搜索失败处的上一层结点
        if ( k < p -> Element.Key)
            p = p -> lChild;
        else if (k > p -> Element.Key)
            p = p -> rChild;
        else
            return false;
    }
    r = NewNode(x);                   // 生成新结点
    if(!bt -> root)
        root = r;                     // r作用是指向新结点
    else if (k < q -> Element.Key)
        q -> lChild = r;              // q指针作用是记录新结点的双亲
    else 
        q - > rChild = r;
    return true;
}
```

### 二叉搜索树删除操作

#### 删除叶结点

![](./image/st4.png)

#### 删除带一个子树的结点

![](./image/st5.png)

首先先断开33和35之间的连线，然后将33与34相连（33的右指针指向34），最后删除35

PS：不能直接删除，但是可以替代，比如上述就是让34替代了原本35的位置，而且 **不会影响有序性**

#### 删除两个子树的结点

![](./image/st6.png)

![](./image/st7.png)

**↑ 所选的代替者肯定没有右子树**

![](./image/st8.png)

**↑ 所选的代替者肯定没有左子树**

**删除有两个孩子的结点**

(1)在二叉搜索树上搜索待删除元素的结点 （**结点两个孩子都非空**）

(2)选择待删除结点在中席遍历序列下的直接 B 代替待删除节点

(3)删除重复的代替者

- 代替者没有孩子：直接删除
- 代替者有一个孩子：孩子直接代替后删除

![](./image/st9.png)



------

## 二叉平衡树

占位



------

## 散列表

占位



------

## 图论

占位



------

## 排序

占位

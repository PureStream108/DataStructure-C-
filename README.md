# DataStructure(C)-Beta版
**南京邮电大学数据结构C语言代码**

每个大章节中我会把文件程序具体是什么放在最前面，然后知识点放在程序后，所以可能顺序会有点不同，可以看

下面目录选择你喜欢的进行查看（ **想看程序分别对应是什么的** 可以直接 **点大章节标题**，比如我直接点树就能看到

对应程序的内容所指）（Github右边可以展开目录）

[TOC]

## 树

binarytree.c（先序、中序、后序遍历）

binarytree2.c（层次遍历）

binarytree3.c（应用-计算结点数量）

treeclear.c（递归清空二叉树）

### 树转化成二叉树

![](./image/bt0.png)

![](./image/bt1.png)

![](./image/bt3.png)

### 二叉树转化成森林

（左孩子，右兄弟）

![](./image/bt4.png)

![](./image/bt5.png)

![](./image/bt6.png)

### 树和森林的存储表示

![](./image/bt7.png)

![](./image/bt8.png)

![](./image/bt9.png)

其中这里的 `sibling` 表示原示例中兄弟结点的下标，比如说B和C是兄弟结点，然后A是-1，B是1，C是2，那么BC（B在C的左边）这个兄弟结点的的 `sibling` 的表示则为： `B -> C(2) -> A(-1)`，也就是上面图示的箭头指向，兄弟结点的最后一个（最右边的）的 `sibling` 即为他的父结点的位置下标

### 森林的遍历

![](./image/bt11.png)

![](./image/bt12.png)

![](./image/bt13.png)

![](./image/bt10.png)

总结就是：

- 森林先序/中序遍历与二叉树的思想基本相同，遍历完相加即可
- 森林后序遍历的头结点是从右往左一次遍历的（D -> A），并不是简单相加
- 层次也差不多



------

## 堆与优先权队列

heap1.c（向下调整算法 && 建堆运算）

queue1.c（优先权队列的实现）

### 什么是堆？

定义:从逻辑结构上看，一个大小为n的堆是一棵包含n个结点的 **完全二叉树**，根结点称为堆顶，包含如下两类：

- 最小堆:树中每个结点的数据都 **小于或等于** 其孩子结点，因此，在最小堆中，堆顶存储的数据是整棵树中最小的;
- 最大堆:树中每个结点的数据 **大于或等于** 其孩子结点，因此，在最大堆中，堆顶存储的数据是整棵树中最大的

![](./image/d1.png)

### 堆的存储表示

就拿上面那个最小堆来举例，堆的存储结构应该遵循的是层次遍历，也就是如下：

```
index:  0   1   2   3   4   5  ....
value: [18, 30, 24, 50, 46, 92]....
```

那么如何判断一个堆是最小堆还是最大堆？

你就从0开始按层次遍历排好，然后观察是不是 **每个结点** 都 **大于等于/小于等于** 其子结点就行

### 建堆运算

我们已知最后一个叶结点双亲的位置是 $$\lfloor\frac{(n-2)}{2}\rfloor$$ ($$\lfloor x\rfloor$$表示向下取整)，根结点位置为 0

**算法思想（最小堆）：** 从最后一个叶子的双亲($$K_{\lfloor(n-2)/2\rfloor}$$)**反方向** 直到根结点($$K_0$$)，依次对其中的每个结点($$K_i$$)执行向

下调整（AdjustDown）操作，步骤如下：

①若该结点小于或等于其最小的孩子，则本轮向下调整结束;否则执行步骤②;

②将该结点与最小孩子交换;交换完成后，继续以该结点为考查对象，再次执行步骤①；

关键算法：（完整代码可以见 heap1.c）

```c
void AdjustDown(ElemType heap[], int current, int border){
    int p = current;
    int minChild;
    ElemType temp;
    while(2 * p + 1 <= border){  // 若p不是叶结点，则执行
        if((2 * p + 2 <= border) && (heap[2 * p + 1] > heap[2 * p + 2]))
            minChild = 2 * p + 2;  // 右子树存在，且较小，则minChild指向p的右子树
        else
            minChild = 2 * p + 1;  // 右子树不存在或较大，则指向p的左子树
        if(heap[p] <= heap[minChild]){
            break;                 // 若当前结点不大于自己的最小的子树，则结束
        }
        else{                      // 否则就将p与最小的子树进行交换
            temp = heap[p];
            heap[p] = heap[minChild];
            heap[minChild] = temp;
            p = minChild;          // 设置下轮循环待考察元素的位置（当前下移元素位置）
        }
    }
}

void CreatHeap(ElemType heap[], int n){
    int i;
    for(i = (n-2)/2; i > -1; i--)      // 从最后一个叶结点的双亲方向到根结点
        AdjustDown(heap, i, n - 1);
}
```

### 优先权队列

**优先权队列** 是一种具有如下特性的数据结构：元素加入数据结构的次序无关紧要，但每次从该数据结构中取元素

时，都只取具有最高优先级的元素，这样的数据结构即为优先权队列

- 每个元素都应有一个优先权，且可以比较大小
- 元素按优先权的高低顺序依次出队，而不是按元素进入队列的先后顺序出队

**实现优先权队列的方法：**

- 进队：将新元素放在堆尾元素后面，并按照（最小堆）或最大堆进行适当调整 ($$O(log_2n)$$)
- 出队：直接取出堆顶元素($$O(1)$$)，取出后，按照（最小堆）或最大堆进行适当调整($$O(log_2n)$$)

**向上调整算法（最小堆）：**

- 设新元素插入在最小堆的元素序列的尾部
- 从新插入元素开始，自底向上，与父结点元素进行大小比较；若父结点大于子结点，则进行交换调整；直到父结点不再大于新元素子结点，或者新元素已经到达了堆顶

关键代码：（完整代码请见 queue1.c）

```c
// 向上调整
void AdjustUp(ElemType heap[], int current){
    int p = current;
    ElemType temp;
    while(p > 0){   // 如果p是根节点了则结束
        if(heap[p] < heap[(p - 1) / 2 ]){  //  // 如果p小于父结点，则进行交换
            temp = heap[p];
            heap[p] = heap[(p - 1) / 2 ];
            heap[(p - 1) / 2 ] = temp;
            p = (p - 1) / 2;   // 更新p的位置使其成为父结点  
        }else {
            break;
        }
    }
}
```

## 哈夫曼树与哈夫曼编码

huffmantree1.c（哈夫曼算法）

### 树的路径长度

**树的内路径长度**：除叶结点外，从根到树中其他所有结点的路径长度之和

![](./image/ht1.png)

**树的外路径长度**：从根到所有叶结点的路径长度之和

![](./image/ht2.png)

我们已知 **扩充二叉树（2-树）** 是一棵 **除了叶结点之外，每个结点都必须有两个子结点**，现在定义内路径长度和外路径长度分别为 `I` 和 `E`，叶结点数量为 `n`，那么有以下公式：

$$
E=I+2n
$$

**叶结点的加权路径长度**：设叶结点是带权的，则叶结点的加权路径长度是其长度与其权值的乘积

**树的加权路径长度**：所有叶结点的加权路径长度之和，记作 `WPL`，有如下公式：

$$
WPL=\sum_{k=1}^{m}w_k \times l_k
$$

其中， $$m$$ 是叶结点的数量， $$w_k$$ 是第 $$k$$ 个结点的权值(圆圈里的数值)， $$l_k$$ 是该叶结点的路径长度

![](./image/ht3.png)

**加权路径长度WPL的内涵**(结合字符编码应用场景)

- 每一个叶结点表示一个字符
- 叶结点权值表示对应字符在文本中的出现频度
- 叶结点的路径长度表示对应字符的编码长度

**WPL 表示的是一个文本最终转换成编码之后的总编码长度**

### 哈夫曼树和哈夫曼算法

**哈夫曼算法**：求具有最小加权路径长度二叉树的算法

**哈夫曼树**:用哈夫曼算法构造生成的二又树

- 哈夫曼树是一棵扩充二叉树
- 哈夫曼树中任一 **非叶节点的权值** 等于其 **左右孩子的权值之和**
- 对于叶节点相同二叉树而言，哈夫曼树的 **加权路径长度是最小的**

由下面的例子来呈现哈夫曼算法的具体步骤：

现有集合 `W = {3, 5, 9, 11, 12，13}`，我们先选取最小的两个权值构成二叉树，即 3 和 5，构造如下：

`F = {8，9，11，12，13}`，其中 <8，3>，<8，5>

![](./image/ht4.png)

然后循环上述步骤，我们能得到 <17，8>，<17，9>

![](./image/ht5.png)

然后我们再选择 11 和 12 进行组合，以此类推，最终生成一个新的二叉树

![](./image/ht6.png)

关键代码如下：（伪代码）（非伪代码可以看 huffmantree1.c）

```c
// 创建哈夫曼树
BinaryTree CreateHFMTree(int w[], int m){
    BinaryTree x, y, z;
    CreatPQ(PQ, m);                       // 初始化用于存储二叉树的优先权队列，权值存在根结点数据域
    for(int i = 0; i< m; i++){
        MakeTree(x, w[i], NULL, NULL);    // 创建只包含根结点的二叉树，并把权值存在根结点数据域
        Append(PQ, x);                    // 将二叉树存入优先权队列
    }
    while(PQ.n > 1){
        Serve(PQ, x);
        Serve(PQ, y);                        // 这两步对应哈夫曼算法中取出两个最小的结点进行结合
        if(x.root.element < y.root.element)  // 设置左子树的权值小于右子树
            MakeTree(z, x.root.element + y.root.element, x, y);
        else
            MakeTree(z, x.root.element + y.root.element, y, x);
        Append(PQ, z);                       // 将合并后的二叉树加入优先权队列
    }
    Serve(PQ, x);          // 获取优先权队列中唯一的二叉树（完整的哈夫曼树），并存入x
    return x;
}
```

### 哈夫曼编码

（为了调上面那个伪代码怒耗时3h，但是给自己定的ddl要到了，遂停摆）

![](./image/ht7.png)

![](./image/ht8.png)

**哈夫曼编码**

利用哈夫曼树构造哈夫曼编码：

已知文本的字符集S，以及对应的权值集合W，权值表示对应字符的频度，执行如下步骤：

1. 根据W构造哈夫曼树，叶结点权值代表对应的字符;
2. 按照左孩子分支标记编码0，右孩子分支标记编码1的原则(左0右1)，为哈夫曼树中的分支标记0/1编码;
3. 叶子节点对应字符的编码，即为从根结点到该叶子节点的路径中，经过各孩子分支所形成的0/1编码序列。

![](./image/ht9.png)



------

## 集合与搜索

jihe1.c（有序表顺序搜索，无序表顺序搜索，有哨兵的有序表顺序搜索）

jihe2.c（二分搜索）

### 集合的抽象数据类型

![](./image/jh1.png)

![](./image/jh2.png)

**常见的集合实现有三种：**

- 线性表（本章节采用线性表）
- 搜索树
- 散列表

**定义顺序表表示下的集合：**

```c
typedef struct {
    int n;
    int maxLength;
    ElemType *element;
}ListSet;
```

（ElementType表示可以比较的类型，要根据实际进行更改）

### 顺序搜索

**顺序表**：采用顺序存储表示来实现的线性表（申请连续的存储空间）

**顺序搜索**：在进行元素查找时，从线性表第一个元素开始，按照位置从前到后依次的进行元素的查找

**无序表的顺序搜索：**

从第一个元素开始，将指定待查找的元素x的关键字与表中元素的关键字一一比较

若相等，搜索成功；若搜索完整个表，不存在关键字值等于给定值的元素搜索失败，例如：

 (41，25，28，33，36，15)

33搜索成功! 35 搜索失败!（需要将每个元素都比较一遍）

顺序搜索无序表的代码实现：

```c
int SeqSearch(ListSet L, ElemType x){
    for(int i = 0; i < L.n; i++)
        if(L.element[i] == x)      // 一个一个搜索直到搜索到为止
            return i;
    return -1;
}
```

如果存在有序表（1， 25， 28， 33， 36， 45），我需要查找35，我可以对代码改动如下：

```c
int SeqSearchOrder(ListSet L, ElemType x){
    for(int i = 0; i < L.n; i++){
        if (L.element[i] == x)
            return i;
        else if(L.element[i] > x)    // 顺序表中是从小到大排列的
            return -1;
    }
    return -1;
}
```

也可以增加一个 **哨兵**（有序表最后添加一个无穷大的数）

```c
int SeqSearchSentry(ListSet L, ElemType x){
    L.element[L.n] = MaxNum;              // 将最后一个设置为无穷大
    for(int i = 0; L.element[i] < x; i++) 
    // 让L中的每个元素跟x比较，若匹配到了最后一个哨兵还没有x，就说明搜索失败
        if(L.element[i] == x)             // 一个一个搜索直到搜索到为止
            return i;
    return -1;
}
```

**对有序表进行顺序搜索比无序表上进行顺序搜索速度更快？**

错误。顺序搜索的时间复杂度在有序表和无序表上都是 O(n)，没有本质区别

### 二分搜索

此章节说明的二分搜索适用于有序表

![](./image/jh3.png)

**对半搜索是二分搜索中的一种，分割点为表的中点元素**： 

$$
m=\frac{low+high}{2}
$$

过程如下：

![](./image/jh4.png)

![](./image/jh5.png)

关键代码：

```c
int BinarySearch(ListSet L, ElemType x, int low, int high){
    if(low <= high){
        int m = (low + high) / 2;
        if(L.element[m] > x)
            return BinarySearch(L, x, low, m - 1); // 中点比x大，说明x在左半边
        else if(L.element[m] < x)
            return BinarySearch(L, x, m + 1, high);// 中点比x小，说明x在右半边
        else
            return m;
    }
    else
        return -1;
}
```

也可以使用while循环：

```c
int BinarySearch(ListSet L, ElemType x){
    int m, low = 0;
    int high = L.n - 1;
    while(low <= high){
     	m = (low + high) / 2;
        if(L.element[m] > x)
            return BinarySearch(L, x, low, m - 1); // 中点比x大，说明x在左半边
        else if(L.element[m] < x)
            return BinarySearch(L, x, m + 1, high);// 中点比x小，说明x在右半边
        else
            return m;  
    }    
    return -1;
}
```

### 平均搜索长度分析

分析一个搜索算法的时间复杂度通常分搜索成功以及搜索失败两种情况加以讨论

为了确定一个指定关键字值的记录在表中的位置，需要进行关键字值之间的比较，这些比较次数的期望值称为搜索

算法的 **平均搜索长度( average search length ASL)**

#### 无序表的顺序搜索

(1)成功搜索的平均搜索长度

设表中元素a,被搜索的概率p;，假定每个元素的搜索概率相等即 $$p_i=\frac{1}{n}$$ ，则搜索成功时的平均搜索长度为：

$$
ASL_s=\sum_{i=1}^{n}i \times p_i=\frac{1}{n}\sum_{i=1}^{n}=\frac{n+1}{2}
$$

(2)搜索失败的平均搜索长度

该函数在搜索失败的情况下，总要进行 **n次** 关键字值之间的比较 

#### 有序表的顺序搜索

(1)成功搜索的平均搜索长度

**与无序表相同**，其公式如下

$$
ASL_s=\sum_{i=1}^{n}i \times p_i=\frac{1}{n}\sum_{i=1}^{n}=\frac{n+1}{2}
$$

(2)搜索失败的平均搜索长度

在搜索失败的情况下，**平均搜索长度大约比无序时快一倍**，其公式如下：

$$
ASL_F=1+\sum_{i=1}^{n+1}i \times \frac{1}{n+1}=2+\frac{n}{2}
$$

其中，循坏内比较了 $$1+\frac{n}{2}$$ 次，判断跳出循环又比较了 $$1$$ 次

![](./image/jh6.png)

#### 二叉判定树构造

![](./image/jh7.png)

![](./image/jh8.png)

这样子构造可以保证每个内结点的左子树都是关键字更小的结点，而右子树都是关键字更大的结点

**搜索(二叉判定树T，k)**

(1)将 (l = 根结点的关键字) 与 (k) 进行比较

(2)如果 l=k，**成功搜索，返回**

(4)如果 I>k，如果T的左子树不为空，**搜索(T的左子树，k)**

**否则，搜索失败，返回**

(5)如果 l<k，如果T的右子树不为空，**搜索(T的右子树，k)**

**否则，搜索失败，返回**

**如果搜索成功，则算法在内结点处终止；否则算法在外结点处终止**

这样构造出来的二叉树有以下特征：(高度为 $$\lfloor log_2n \rfloor+1$$ 的二叉树 ) 

- 任意结点左右子树上结点个数差 = 1
- 左右子树高度差最多为 1

**定理**  对半搜索算法在成功搜索的情况下，关键字值之间的比较次数不超过 $$\lfloor log_2n \rfloor+1$$;对于不成功的搜索，算法需要作 $$\lfloor log_2n \rfloor$$ 或 $$\lfloor log_2n \rfloor+1$$ 次比较 

**定理** 对半搜索算法的成功/失败的平均时间复杂度为 $$O(log_2n)$$

![](./image/jh9.png)





------

## 搜索树

searchtree1.c（二叉搜索树的搜索、插入、删除）

### 二叉搜索树

#### 二叉搜索树的定义

**定义** 设结点由关键字值表征，假定所有结点的 **关键字值各不相同**，二叉搜索树或者是一棵空二叉树或者是具有下

列性质的二叉树:

(1)若左子树不空，则左子树上所有结点的关键字值均小于根结点关键字值;

(2)若右子树不空，则右子树上所有结点的关键字值均大于根结点关键字值;

(3)左、右子树也分别是二叉搜索树

![](./image/st1.png)

**性质** 若以中序遍历一棵二叉搜索树，将得到一个以关键字 **递增** 排列的有序序列

**中序遍历**：23 35 45 54 63 69 76 87

#### 二叉搜索树中序遍历的特征

任何一个结点：

- 左子树上的结点都在它的左侧排列;
- 右子树上的结点都在它的右侧排列，

再结合二叉搜索树左小右大的原则，任何一个结点：

- 左子树上的结点都在它的左侧排列且都比它小
- 右子树上的结点都在它的右侧排列且都比它大

#### 类型实现

定义值集合项类型 T 包含值与键

```c
typedef int KeyType;
struct entry{
    KeyType Key;
    DataType Data;
}Entry;
typedef struct Entry T;
```

定义搜索树：

```c
// 定义搜索树节点类型BTNode, 包含集合项、左右子树根结点指针
typedef struct btnode{
    T Element;
    struct btnode *lChild, *rChild;
}BTNode;

// 定义搜索树类型BTree，包含根结点
typedef struct btree{
    BTNode *root;
}BTree;
```

#### 二叉搜索树搜索操作

**二叉搜索树的搜索操作**

在一棵二叉搜索树上，查找关键字为k的元素

(1)若二叉树为空，则搜索失败

(2)否则，将k与根结点比较

- 若k小于该结点的关键字，则以同样的方法搜索左子树，而不必搜索右子树，
- 若k大于该结点的关键字，则以同样的方法搜索右子树，而不必搜索左子树，
- 若k等于该结点的关键字，则搜索成功终止

#### 二叉搜索树插入操作

![](./image/st2.png)

![](./image/st3.png)

关键代码：

```c
// 搜索树插入操作
bool Insert(BTree *bt, T x){
    BTNode *p = bt -> root, *q, *r;    // p指针从根结点出发一直到搜索结束
    KeyType k = x.Key;
    while(p){
        q = p;                         // q指针记录搜索失败处的上一层结点
        if ( k < p -> Element.Key)
            p = p -> lChild;
        else if (k > p -> Element.Key)
            p = p -> rChild;
        else
            return false;
    }
    r = NewNode(x);                   // 生成新结点
    if(!bt -> root)
        root = r;                     // r作用是指向新结点
    else if (k < q -> Element.Key)
        q -> lChild = r;              // q指针作用是记录新结点的双亲
    else 
        q - > rChild = r;
    return true;
}
```

#### 二叉搜索树删除操作

##### 删除叶结点

![](./image/st4.png)

##### 删除带一个子树的结点

![](./image/st5.png)

首先先断开33和35之间的连线，然后将33与34相连（33的右指针指向34），最后删除35

PS：不能直接删除，但是可以替代，比如上述就是让34替代了原本35的位置，而且 **不会影响有序性**

##### 删除两个子树的结点

![](./image/st6.png)

![](./image/st7.png)

**↑ 所选的代替者肯定没有右子树**

![](./image/st8.png)

**↑ 所选的代替者肯定没有左子树**

**删除有两个孩子的结点**

(1)在二叉搜索树上搜索待删除元素的结点 （**结点两个孩子都非空**）

(2)选择待删除结点在中席遍历序列下的直接 B 代替待删除节点

(3)删除重复的代替者

- 代替者没有孩子：直接删除
- 代替者有一个孩子：孩子直接代替后删除

![](./image/st9.png)

### 平衡树

#### 二叉平衡树的定义

二叉平衡树或者是一棵空二叉搜索树，或者是具有下列性质的二叉搜索树

(1)其根的左、右子树高度之差的绝对值不超过1;

(2)其根的左、右子树都是二叉平衡树

![](./image/ph1.png)

**定义** 结点的平衡因子

结点的平衡因子被定义为该结点的左子树高度减去右子树的高度

![](./image/ph2.png)



#### 二叉平衡树的插入运算

二又平衡树的插入运算可按如下两条基本原则进行：

- 原则1：先按普通二叉搜索树的插入方法插入结点以保持 **排序性** 
- 原则2：然后再判断二又平衡树的平衡性是否被破坏，从而决定是否需要调整 **平衡性**

![](./image/ph3.png)

如图，插入25后，任何根结点的左右子树高度差绝对值不超过1，所以25被正常插入

![](./image/ph4.png)

如图，插入14后，发现根结点的左右子树高度差绝对值大于1（12所在的根结点和33所在的根结点），所以插入失败，需要进行 **平衡性的调整**

**基本原则**：

- 找到需要调整的最小子树
- 调整最小子树的平衡性

**如何找到需要调整的最小子树？**

最小子树的根结点s 即为离新插入结点最近且平衡因子绝对值超过1的祖先结点，也就是插入后由新结点回溯至根结点的路径上第一个出现的非平衡结点

**如何调整最小子树的平衡性？**

根据 **新结点在最小子树s上的插入类型** 来选择不同的平衡

- 如果属于LL(RR)插入类型，即新结点插入s的左(右)子树的左(右)子树上，则采用 **单旋转方法**
- 如果属于LR(RL)插入类型，即新结点插入s的左(右)子树的右(左)子树上，则采用 **双旋转方法**

而且是怎么插入的，旋转也按照插入的LR顺序进行

![](./image/ph5.png)

这里是LL的插入类型，也就是插入在14的左子树的左子树上，所以我们现在标记14为s，那么下一个12标记为r，然后就是将r和s沿顺时针方向转动，让s变成r的右子树

![](./image/ph6.png)

![](./image/ph7.png)

**二叉平衡树的插入算法**

在一棵二叉平衡树上，插入新元素的手工算法可描述如下：

1. 按照 **二叉搜索树的插入方式插入新元素**
2. 判断插入新元素后的二叉平衡树其平衡性是否被破坏，**如果平衡性没有破坏**，**则插入运算结束**
3. 否则，如果 **平衡性被破坏**，则标记s结点为插入后由新结点回湖至根结点路径上第一个出现的非平衡结点，然后判断插入类型：

- 如果插入类型为 **LL/RR**，采用 **单旋转方式** 调整最小子树的平衡性
- 如果插入类型为 **LR/RL**，则采用 **双旋转方式** 调整最小子树的平衡性

#### 例题

例题如下：

对空树的二叉平衡树，依次输入A，Z，B，T，C，P 所构造的二叉平衡树的根结点为 _______（字母根据在字母表的编号比较大小，A-Z的编号为1~26）

答案：C

解析：

**第1步：插入 A**

```
  A
```

**第2步：插入 Z**

```
  A
   \
    Z
```

**第3步：插入 B**

插入后失衡，进行 **RL旋转**（先右旋Z，再左旋A）

```
  插入后：        右旋Z：        左旋A：
    A               A             B
     \               \           / \
      Z       →       B    →    A   Z
     /                 \       /     \
    B                   Z     null    null
```

**结果**：

```
    B
   / \
  A   Z
```

**第4步：插入 T**

```
    B
   / \
  A   Z
     /
    T(20)
```

**第5步：插入 C**

插入后Z节点失衡，进行 **LL旋转**

```
    B                  B
   / \                / \
  A   Z     →        A   T
     /                  / \
    T                  C   Z
   /
  C
```

**结果**：

```
    B
   / \
  A   T
     / \
    C   Z
```

**第6步：插入 P**

插入后B节点失衡，进行 **RL旋转**

```
    B                  B                  C
   / \                / \                / \
  A   T     →        A   C     →        B   T
     / \                / \            / \   \
    C   Z              P   T          A   P   Z
     \                     /
      P                   Z
```

**最终结果**：

```
        C
       / \
      B   T
     /     \
    A       Z
     \     /
      P   null
```

**修正后的标准RL旋转**：

```
    B                  B                  C
   / \                / \                / \
  A   T     →        A   C     →        B   T
     / \                / \            / \   \
    C   Z              P   T          A   P   Z
     \                     / \
      P                   null Z
```

**最终平衡树**：

```
        C
       / \
      B   T
     / \   \
    A   P   Z
```

‍

### B-树

#### m叉搜索树的定义

![](./image/b1.png)

图中的方块代表空树

**空树** 也被称为 **失败结点**，因为这是当搜索某个关键字不在树中所到达的子树

失败结点中不包含元素，**失败结点不是叶结点**

**m叉搜索树的递归定义：**

![](./image/b2.png)

![](./image/b3.png)

从定义中可以得到：

(1)一个m叉搜索树的结点中，**最多** 存放 **m-1个元素** 和 **m个指向子树的指针**

(2)每个结点中包含的元素个数比它包含的指针数少1

**内搜索和外搜索**

**内搜索**：当集合足够小，可以驻留在内存中时，相应的搜索方法称为内搜索

**外搜索**：如果文件很大，以至于计算机内存容不下时，它们必须存放在外存中。在外存中搜索给定关键字值的元素的方法称为外搜索

**内存中**，集合用 **二叉平衡树** 表示。**外存中**，集合可以用一种特殊的 **m叉搜索树--B-树** 来表示

由于读取外存的速度要比内存慢百倍，所以平时读取外存就可以将二叉树压成B-树：

![](./image/b4.png)

如上图，将一棵高度为6的二叉搜索树压缩成单结点存放7个元素、高度为2的8叉树，大大提高了搜索速度

#### m叉搜索树的性质

**性质1**：高度为 $$h$$ 的 $$m$$ 叉搜索树中最多有 $$m^h-1$$ 个元素

**性质2**：含有 $$N$$ 个元素的 $$m$$ 叉搜索树的高度在 $$log_m(N-1)$$ 到 $$N$$ 之间

#### B-树的定义

**定义** 一颗m阶B-树是一棵m叉搜索树，它或者是空树，或者是满足以下特性的树：

- 根结点 **至少有两个** 孩子 （根结点可以只有一个元素）
- 除根结点和失败结点外的所有结点 **至少** 有 $$\lceil \frac{m}{2} \rceil$$ 个孩子 （保证B-树不会退化成单分支树）
- 所有失败结点均在同一层上

**如何判断是不是B-树？如何判断是几阶B-树？**

- 首先看失败结点是否在同一层上
- 其次查看根结点是否最少有两个孩子
- 然后确定m的值，并计算 $$\lceil \frac{m}{2}\rceil$$ 是多少
- 最后查看每个结点(根结点和失败结点除外)的孩子数量有没有少于 $$\lceil \frac{m}{2}\rceil$$ ？

![](./image/b5.png)

比如这个图，每个根结点下至少有2个孩子，所以此树既是3阶B-树，也是4阶B-树，但是绝对不可能是5阶B-树，因为 $$\lceil \frac{m}{2}\rceil$$ 至少为3，而图中存在有两个孩子的结点

#### B-树的性质

**性质1** 设B-树失败结点的总数是 $$s$$ ，那么，一棵B-树包含的元素总数 $$N$$ 是B-树的失败结点的总数 $$s-1$$ ，即 $$N=s-1$$

**性质2** 含有 $$N$$ 个元素的m阶B-树的高度 $$h$$ 有 $$h≤1+log_{\lceil \frac{m}{2}\rceil}\frac{N+1}{2}$$

#### B-树的搜索

在B-树上进行搜索的过程是一个 **顺时针查找结点**，和 **在结点的关键字中搜索** 交叉进行的过程

#### B-树的插入

B-树插入应遵循的基本原则：

- 首先执行 **搜索** 操作，判断元素是否存在;
- 如果元素不存在，则将元素依某种插入规则插入B-树;
- 如果插入后没有违反B-树的定义，则插入成功完成;否则需作相应调整

![](./image/b6.png)

![](./image/b7.png)

**上溢出**：关键字个数 > $$m-1$$

此时插入59后，结点个数突破上限3（上溢出），就要进行下一步调整操作：

![](./image/b8.png)

总结步骤如下：

- **Step 1**：搜索。在B-树中搜索给定关键字值的元素。如果搜索成功，表示有重复元素，则插入运算结束；**否则转Step 2将新元素插入搜索失败结点上一层处的叶子结点q中**
- **Step 2**：插入。将新元素和一个空指针插入结点q中。如果插入后，结点q未上溢出，即结点中包含的元素个数未超过 $$m-1$$ (指针数未超过m)，则插入运算结束。**否则转Step3进行结点的分裂操作**
- **Step 3**：分裂。以 $$\lceil \frac{m}{2}\rceil$$ 处的元素为分割点，将上溢出结点一分为三，然后将分割点元素和新结点插入双亲结点中。继续检查此双亲结点的上溢出问题。如果没有上溢出，则插入运算结束，**否则转Step 3继续该双亲结点的分裂操作，直至不再产生上溢出现**

**Tips**：如果按照Step3，**根结点产生分裂**，由于根结点没有双亲，那么分裂产生的两个结点的指针以及分割点元素将组成一个新的根结点，从而 **将导致B树长高一层**

#### B-树的删除

**B-树删除应遵循的基本原则**：

首先执行搜索操作，判断元素是否存在，如果被删除元素存在，则分情况执行删除操作：

- 情形1：被删除的元素 **在叶子结点上**。则直接从该叶子结点中删除该元素，并检查是否发生下溢出。如果没有下溢出，则删除运算结束，否则处理下溢出
- 情形2：被删除的元素 **不在叶子结点上**。则首先执行 **替代** 操作，用该元素 **右侧子树上的最小元素取代它** ，从而将问题转化为情形1

![](./image/b9.png)

![](./image/b10.png)

在B-树（B-tree）中，**下溢出（Underflow）** 是指删除操作后，某个非根节点的键数量低于最小允许值的情况

B-树中，根结点至少有1个键，非根结点至少要有 $$\lceil \frac{m}{2} \rceil -1$$ 个键

| 特性         | 上溢出（Overflow） | 下溢出（Underflow）                         |
| ------------ | ------------------ | ------------------------------------------- |
| **触发操作** | 插入键时           | 删除键时                                    |
| **条件**     | 节点键数 > $$m-1$$ | 节点键数 < $$\lceil \frac{m}{2} \rceil -1$$ |
| **解决方法** | 节点分裂（Split）  | 借键或合并（Borrow/Merge）                  |

就是说我4阶B-树有个叶结点只有一个键值，然后现在删除了，然后这个结点变成了0个键值，所以触发了下溢出

![](./image/b11.png)

![](./image/b12.png)

**旋转地借** 元素，而不是简单将47借过来

如果你说：如果我想要删除的元素发生了下溢出但是没有富裕的兄弟给我借怎么办？？

那好，看下面这个例子：

![](./image/b13.png)

此时左边没有富裕，右边没有，那删除之后该怎么办呢？答案是 **并**

![](./image/b14.png)

具体地，可将下溢出结点与其左、右侧兄弟之一合并(如果左、右侧兄弟同时存在，则**优先与左侧兄弟结点合并**);

同时将双亲结点的一个元素(即夹在合并的左、右侧子树之间的关键字)移到合并后的结点中组成新的结点

如果合并之后双亲结点发生了下溢出，则继续执行 **先借后并** 的操作：

![](./image/b15.png)

**为什么要把43移过来**？因为在B-树中，**子结点数 = 键数 + 1**

总结B-树删除运算的步骤：

Step 1：**搜索**。在B-树中搜索给定关键字值的元素。如果搜素不成功，则删除运算结束。否则转Step 2执行元素的删除操作

Step 2：**删除**。首先判断删除类型，根据删除类型选用相应的删除方法：

- 如果属于情形1，即被删除的元素在叶子结点中，则转Step 3执行从叶子结点中删 除该元素的操作;
- 如果属于情形2，即被删除的元素不在叶子结点中，则用该元素右侧子树上的最小元素取代它，从而将问题转化为情形1，然后转Step3执行从叶子结点中删除该元素的操作

Step 3：**从叶子结点中删除元素。**首先从叶子结点中直接删除该元素，如果删除元素后没有下溢，则删除运算结束。否则 **首先考虑采用“借”** 的方法处理下溢出，如果左右两侧兄弟结点都没有富余，则采用“并”的方法处理下溢出，然后继续检查其双亲结点的下溢出问题。如果没有下溢出，则删除运算结束，否则继续该双亲结点的**先“借”后“并”** 操作直至不再有下溢出现象产生

**Tips**：如果由于“并”操作，导致根结点中的一个元素被删除，并且该结点只包含一个元素，则根结点成为不包含任何元素的空结点，此时B-树将变矮一层



------

## 散列表

hashtable.c（线性探查）

### 基本概念

**散列表**：集合元素以一种 "分散" 的方式零散的存放在顺序表中

**散列的基本概念**：

- **散列函数 (h, hash)**：集合元素的关键字(key)与其存储位置(Loc)之间的关系函数，散列函数计算出的值也称为散列值
- **Loc(key)**： 表示关键字值为key的集合元素的存储地址
- **散列表 (hash table,哈希表)**：用散列函数建立起来的表，用于存储集合元素

![](./image/sl1.png)

![](./image/sl2.png)

发现一：

对于 $$h_1$$ ：JIANGSHU 与 JIANGXI 等被映射到相同位置，产生冲突

对于 $$h_2$$ ：SHANGHAI 与 SHANXI 被映射到相同位置，产生冲突

**冲突**： $$key1 ≠ key2$$ ，但 $$h(key1)=h(key2)$$ 的现象

**同义词**：对给定 $$h$$，具有相同散列值的不同关键字

发现二：

散列函数 $$h_1(key)$$ 发生冲突的次数明显少于散列函数 $$h_2(key)$$

这说明 **散列函数的选择是有原则的**

![](./image/sl3.png)

$$h_1(key)$$ 发生冲突的次数明显少于散列函数 $$h_2(key)$$，说明冲突与散列函数相关散列函数是一个 **压缩映象**，**冲突不可避免**！可以做到的是：

- 选择“好”的h，尽量减少冲突
- 如果发生冲突，如何处理? 用 **冲突处理技术**

### 常见散列函数

**什么是好的散列函数？**

- **确定性**：同一值总被映射到同一地址
- **快速**：最好是O(1)
- **满射**：尽可能充分覆盖整个散列表存储空间
- **均分布**：为了充分利用散列空间和降低冲突，要使映射到各个位置的概率接近，避免很多元素扎堆聚集的现象

![](./image/sl4.png)

![](./image/sl5.png)

![](./image/sl6.png)

![](./image/sl7.png)

![](./image/sl8.png)

![](./image/sl9.png)



### 冲突处理技术

#### 拉链法

拉链法分为：

- 开散列法 Open Hashing
- 拉链法 Separate Chaining
- 闭散列法 Closed Hashing （开放地址法 Open Addressing）

**开散列法与闭散列法**

相同点：

- 都具有一个散列表和至少一个散列函数
- 对散列函数的要求一致：均分布、计算快速等不同点

不同点：

- **开散列法** 将集合元素存储在 **散列表主表之外** （Open Hashing）
- **闭散列法** 将集合元素存储在 **散列表主表之内** （Closed Hashing）

**拉链法**：

- 所有关键字互为同义词的集合元素存储在 **同一个单链表上**
- 所有单链表的头指针存入一个长度为 $$M$$ 的散列表中
- 单链表的头指针在散列表中的存储位置通过散列函数计算得到

![](./image/sl10.png)



同一个头结点存放的都是同义词，比如图中的11，33，55，66，这些都是散列值为0的同义词

有 $$n$$ 个元素的散列表，其每个单链表的平均长度为 $$\frac{n}{M}$$

**集合元素的查找操作**：

- 计算散列值 $$h(key)$$
- 到散列表 $$h(key)$$ 位置处取出单链表头指针
- 遍历链表进行查找：比较key

拉链表发的插入、查找、删除的时间复杂度为： $$O(\frac{n}{M})$$

![](./image/sl11.png)

开放地址法包括：**线性探查法**、**二次探查法**、**双散列法**

#### 线性探查法

线性探查法使用的探查序列如下：

$$h(key),h(key)+1, h(key)+2 ...,M-1.0,1,...,h(key)-1$$ 插入元素时，从 $$h(key)$$ 开始，若被占用，检查 $$h(key)+1$$，若也占用，再检查探测序列中的下个位置，直到某个位置为空时，将关键字插入该位置

![](./image/sl12.png)

如图，假如说就连 $$h(key)+3$$ 也被占用了，但此时已经到了表的尽头了，就通过取模操作，回到原点继续向后寻找是否有空的位置，另一个例子如下：

![](./image/sl13.png)

##### 搜索操作

基本思想：从基位置 $$h(key)$$ 开始，按照线性探查序列查找元素
搜索成功：找到关键字值为key的元素
搜索失败：

- 遇到一个空位置
- 探查到 $$h(key)$$ 前一个位置(表满)

![](./image/sl14.png)

遇到空位置，搜索失败

![](./image/sl15.png)

满表也找不到25，搜索失败（装载因子 $$\alpha = \frac{n}{M}$$）

##### 删除操作

![](./image/sl16.png)

如果直接抹去58的话，那么4这个地方就空出来了，然后此时搜索35，由于规定遇到空的位置就算搜索失败，所以即使35存在于散列表中，也被当作搜索失败

**删除时需考虑两点**：

- 不能简单清除元素，否则会隔离探查序列后面的元素影响搜索
- 删除元素后，该位置能够重新使用

**解决的办法**：

- 为每个位置增加标志域empty，表示该位置是否使用过
- 删除元素时，不改变标志位，仍为False，元素值改为NeverUsed

![](./image/sl17.png)

如果为True，就表示从未被使用过，如果是Flase但是标着NU，就说明使用过，但是被删除了

![](./image/sl18.png)

改进之后，遇到被删除的58的位置，由于还是False，所以不算查找失败，就向后继续查找

如果搜索25，跟上面搜索35一样，跳过NU但是False的位置，但是遇到后面6的NU但是True就返回失败

##### 插入操作

- 搜索，若搜索结果为存在重复元素则插入失败
- 如果搜索不到，但是表已满，则插入失败
- 如果搜索不到，线性探查第一个值为NeverUsed的位置，插入新元素，并将empty设为F

![](./image/sl19.png)

![](./image/sl20.png)

**线性探查法的缺点**：

- 很快表中所右位置的empty都变成F
- 易使元素在表中连成一片(线性聚集)探查次数增加，影响搜索效率

**改进方法**：

- 二次探查法
- 双散列法

##### 例题

散列查找中1个关键字具有同一散列值，若用线性探查法将这k个关键字对应的记录存入散列表中，至少要进行___次探查

答案： $$\frac{k(k+1)}{2}$$

#### 二次探查法

二次探查法的探查序列：

$$h(key),, h_1(key), h_2(key), ..., h_{2i-1}(key), h_{2i}(key),...$$

其中 $$h(key)$$ 表示初始计算得到的位置（基地址），如果 $$h(key)$$ 被占用，则进行一定的偏移计算

探查序列由下列函数得到：

$$
h_{2i-1}(key)=(h(key)+i^2)  \% M
$$

$$
h_{2i}(key)=(h(key)-i^2)\% M
$$

$$
其中：i=1,2,..,\frac{M-1}{2}
$$

![](./image/sl21.png)

![](./image/sl22.png)

二次探查法能改善“线性聚集"

但是同义词会有相同的探查査序列，产生 **“二次聚集**” ，比如说前一个数进行多次探查后插入了一个位置，但是后一个数的基地址刚好在前一个数插入的位置，那么新的数想要插入，就可能要重走前面的探查路径

#### 双散列法

双散列法的探查序列：

具备两个散列函数 $$h_1$$ （用于计算基地址）和 $$h_2$$ （用于计算偏移量），探查序列为：

$$
h_1(key), (h_1(key)+ h_2(key))\%M, (h_1(key)+2h_2(key))\%M, ...
$$

总结就是：

$$
(h_1(key)+ i*h_2(key))\%M, ...
$$
其中：$$i=0,1,2,3....$$

![](./image/sl23.png)



------

## 图论

### 基本概念

- **图(Graph)**：是数据结构 $$G=(V,E)$$ ，其中 $$V$$ 是 $$G$$ 中结点的 **有限非空** 集合，结点的偶对称为**边(Edge)**；  $$E$$ 是 $$G$$ 中边的有限集合，其中 **V不能为空，但是E可以为空**
- 图中的 **结点** 又称为 **顶点(Vertex)**
- 如果图中代表边的 **偶对是有序** 的，则该图称为 **有向图(Directed Graph)**，用 $$<u,v>$$ 表示一条 **有向边**： $$U ----> V $$，其中 $$U$$ 称为该边的 **始点(尾)**， $$V$$ 称为该边的 **终点(头)**
- 如果图中代表边的 **偶对是无序** 的，则该图称为 **无向图(Undirected Graph)**
- 在无向图中，边 $$(u, v)$$ 和边 $$(v, u)$$ 是同一条边

![](./image/pic1.png)

![](./image/pic2.png)

其中 `<>` 就代表是有序数对

**自回路**：如果图中存在无向边 $$(u,u)$$ 或有向边 $$<u,u>$$ ，则称这样的边为 **自回路**

**多重图**：指图中两个顶点间允许有多条相同的边

![](./image/pic3.png)

**完全图**：如果一个图有最多的边数，称为完全图

包含 **n个顶点** 的 **无向完全图** 有 $$\frac{n(n-1)}{2}$$ 条边

包含 **n个顶点** 的 **有向完全图** 有 $$n(n-1)$$ 条边

**邻接与关联**：如果 $$(u,v)$$ 是无向图中的一条边，则称顶点 $$u$$ 和 $$v$$ **相邻接**，并称边 $$(u,v)$$ 与顶点 $$u$$ 和 $$v$$ **相关联**

例如：下图是一个无向完全图

![](./image/pic4.png)

**子图**：图 $$G$$ 的一个子图是图 $$G’=(V'(G'),E'(G'))$$  ，其中 $$V'(G') \subseteq V(G)$$ ， $$E'(G') \subseteq E(G)$$

![](./image/pic5.png)

如图， $$G_3$$ 是 $$G_1$$ 的子图， $$G_4$$ 是 $$G_2$$ 的子图

**路径**：在无向图 $$G$$ 中，一条从 $$s$$ 到 $$t$$ 的路径是存在一个顶点序列 $$(s,v_1,v_2,v_3...v_k,t)$$ 使得 $$(s,v_1),(v_2,v_3)…… (v_k,t)$$ 都是图 $$G$$ 中的边

对于有向图顶点序列 $$(s,v_1,v_2,v_3...v_k,t)$$ ，应使 $$(s,v_1),(v_2,v_3)…… (v_k,t)$$ 都是图 $$G$$ 中的边

**路径长度**：指路径上边的数目

**简单路径**：除起点和终点可以相同外，路径上其余顶点各不相同

无向图中如果两个顶点 $$u$$ 和 $$v$$ **之间存在一条路径**，则称顶点 $$u$$ 和 $$v$$ 是 **连通的**，否则是不连通的

**连通图**：无向图中如果 **任意两个顶点之间是连通的**，则称该无向图为 **连通图**

![](./image/pic6.png)

**连通分量**：无向图的极大连通子图

![](./image/pic7.png)

**求无向图的连通分量应该注意**：

- 图中连通分量可能有多个，不能只写顶点个数最多的那个连通分量
- 如果某个连通子图再加上一个顶点后，仍每个连通分量必须是极大的。是连通的，则它不是连通分量（**如果某个连通子图加上一个顶点后，仍是连通的，那这个子图就不是连通分量**）
- 每个连通分量必须包含其顶点之间的所有边

![](./image/pic8.png)

**强连通图**：**有向图** 中如果任意两个顶点 $$u$$ 和 $$v$$ 之间，存在一条从 $$u$$ 到 $$v$$ 的路径，同时存在一条从 $$v$$ 到 $$u$$ 的路径，则称该有向图为强连通图

**强连通分量**：有向图的极大强连通子图

![](./image/pic9.png)

如图， $$G_1$$ 是强连通图， $$G_2$$ 不是强连通图，但是存在三个强连通分量（图中左三），同理 $$G_3$$ 也不是强连通分量，但是有两个强连通分量（图右一）

**顶点的度**：与该顶点相关联的边的数目

**入度**：有向图中顶点 $$v$$ 的 **入度** 指以 $$v$$ **为头**的边的数目

**出度**：有向图中顶点 $$v$$ 的 **出度** 指以 $$v$$ **为尾**的边的数目

**生成树**：**无向连通图** 的 **生成树** 是一个 **极小连通子图**，它 **包含图中所有顶点**，但只有足以构成一棵树的 $$(n-1)$$ 条边，再加上一条边将构成回路

**极小连通子图**：边数 **最少** 的连通子图。删除 **任意一条边**，图就会 **失去连通性**（断开）

![](./image/pic10.png)

**网**：在图的每条边上加上一个数字作为边的权值(代价)，这种带权的图称为网

![](./image/pic11.png)

![](./image/pic12.png)







------

## 排序

占位

